@page "/"
@rendermode InteractiveServer
@inject IJSRuntime JSRuntime
@inject IApiReaderService apiReader
@inject IJsonDeserializerService jsonDeserializer;
@using System.Text;
@using System.Text.Json.Serialization;
@using System.Text.RegularExpressions
@using WeatherBlazor.Data.Model
@using WeatherBlazor.Services

<PageTitle>Forecast</PageTitle>

<h3>Weather Forecast</h3>

@if (_forecastAsJson is not null)
{
	if (_forecastRoot is not null)
	{
		if (_hourlyForecastRoot is not null)
		{
			HourlyForecastPeriod? currentHourForecast = GetClosestHourlyForeCast(_hourlyForecastRoot);
			List<string>? currentAlerts = GetAlertEventsForToday();

			<div class="current-forecast-banner">
				<div class="current-forecast-content">
					<div class="banner-image-container">
						<img src="@GetHourlyForecastImageUrl(currentHourForecast)" alt="Current Weather Icon" class="banner-weather-icon" />
					</div>
					<div class="banner-text">
						<p><strong>Current Conditions:</strong> @currentHourForecast.temperature @currentHourForecast.temperatureUnit, @currentHourForecast.shortForecast</p>

						@if (currentAlerts is not null)
						{
							<div class="current-alert-list">
								@foreach (var alert in currentAlerts)
								{
									<p class="current-alert-event"><strong>Alert: @alert</strong></p>
								}
							</div>
						}
					</div>
				</div>
			</div>

		}

		<div class="forecast-container">
			@foreach (ForecastPeriod period in _forecastRoot.properties.periods)
			{
				List<string>? alerts = GetAlertEventsForPeriod(period);

				<div class="forecast-tile">

					<p><strong>@period.name</strong></p>

					<div class="image-container">
						<img src="@GetForecastImageUrl(period)" alt="Weather icon" class="weather-icon" />

						@if (period.probabilityOfPrecipitation.value > 0)
						{
							<div class="precipitation-chance">
								@period.probabilityOfPrecipitation.value %
							</div>
						}
					</div>

					<p><strong>@period.temperature @period.temperatureUnit</strong></p>

					<p><strong>@period.shortForecast</strong></p>

					<p><strong>@DescribeWindSpeed(period.windSpeed)</strong></p>

					@if (alerts is not null)
					{
						<div class="alert-list">
							@foreach (var alert in alerts)
							{
								<p class="alert-event"><strong>Alert: @alert</strong></p>
							}
						</div>
					}
				</div>
			}
		</div>

	}


	<style>
		.iframe-container {
			width: 100%;
			height: 600px;
			border: 0;
			overflow: hidden;
		}

			.iframe-container iframe {
				width: 100%;
				height: 100%;
				border: 0;
			}
	</style>

	<div class="iframe-container">
		<iframe
			class="iframe-weatherRadar"
			src="https://radar.weather.gov/?settings=v1_eyJhZ2VuZGEiOnsiaWQiOiJ3ZWF0aGVyIiwiY2VudGVyIjpbLTkzLjE0MSwzNS4yNzhdLCJsb2NhdGlvbiI6Wy05My4xNDEsMzUuMjc4XSwiem9vbSI6NywibGF5ZXIiOiJicmVmX3FjZCJ9LCJhbmltYXRpbmciOnRydWUsImJhc2UiOiJzdGFuZGFyZCIsImFydGNjIjpmYWxzZSwiY291bnR5IjpmYWxzZSwiY3dhIjpmYWxzZSwicmZjIjpmYWxzZSwic3RhdGUiOmZhbHNlLCJtZW51Ijp0cnVlLCJzaG9ydEZ1c2VkT25seSI6dHJ1ZSwib3BhY2l0eSI6eyJhbGVydHMiOjAuNzYsImxvY2FsIjowLjYsImxvY2FsU3RhdGlvbnMiOjAuOCwibmF0aW9uYWwiOjAuNn19"
			allowfullscreen>
		</iframe>
	</div>

	<a href="https://www.vecteezy.com/free-vector/weather">Weather Vectors by Vecteezy</a>
}
else
{
	<p>Loading weather data...</p>
}



@code{
	private bool _isFirstRender = true;

	private const string _dayFormat = "dddd";
	private const string _timeFormat = "HH:mm";

	private Location? _location;

	private const string _baseAddress = "https://api.weather.gov/";

	private string? _forecastAsJson;
	private string? _pointRootAsJson;
	private string? _hourlyForecastAsJson;

	private PointRoot? _pointRoot;
	private ForecastRoot? _forecastRoot;
	private HourlyForecastRoot? _hourlyForecastRoot;
	private AlertRoot? _alertRoot;

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (_isFirstRender)
		{
			_isFirstRender = false;

			_location = await GetLocation();

			if (_location is null)
			{
				Console.WriteLine("Location data is not available.");
				return;
			}

			string pointRequestUri = string.Empty;
			string allAlertsUri = string.Empty;
			string activeAlertsUri = string.Empty;
			if (_location is not null)
			{
				pointRequestUri = $"/points/{_location.Latitude},{_location.Longitude}";
				allAlertsUri = $"/alerts?point={_location.Latitude},{_location.Longitude}";
				activeAlertsUri = $"/alerts/active?point={_location.Latitude},{_location.Longitude}";
			}

			_pointRootAsJson = await GetRootJson(_baseAddress, pointRequestUri);

			_pointRoot = SetRoot<PointRoot>(_pointRootAsJson ??
				throw new ArgumentNullException(
					$"{nameof(SetRoot)} was called with {nameof(_pointRootAsJson)} as null."));

			string? forecastFullUrl = _pointRoot?.properties.forecast;
			string? hourlyForeCastFullUrl = _pointRoot?.properties.forecastHourly;

			string? forecastUri = forecastFullUrl?[_baseAddress.Length..];
			string? hourlyForecastUri = hourlyForeCastFullUrl?[_baseAddress.Length..];

			// Getting JSONs
			_forecastAsJson = await GetRootJson(_baseAddress, forecastUri ??
				throw new ArgumentNullException(
					$"{nameof(GetRootJson)} was called with {nameof(forecastUri)} as null."));

			_hourlyForecastAsJson = await GetRootJson(_baseAddress, hourlyForecastUri ??
				throw new ArgumentNullException(
					$"{nameof(GetRootJson)} was called with {nameof(hourlyForecastUri)} as null."));

			string alertsAsJson = await GetRootJson(_baseAddress, allAlertsUri);

			string activeAlertsAsJson = await GetRootJson(_baseAddress, activeAlertsUri);

			// Setting Roots
			_forecastRoot = SetRoot<ForecastRoot>(_forecastAsJson ??
				throw new ArgumentNullException(
					$"{nameof(SetRoot)} was called with {nameof(_forecastAsJson)} as null."));

			_hourlyForecastRoot = SetRoot<HourlyForecastRoot>(_hourlyForecastAsJson ??
				throw new ArgumentNullException(
					$"{nameof(SetRoot)} was called with {nameof(_hourlyForecastAsJson)} as null."));

			_alertRoot = SetRoot<AlertRoot>(alertsAsJson);

			StateHasChanged();
		}
	}

	private T SetRoot<T>(string rootAsJson)
	{
		ArgumentNullException.ThrowIfNull(rootAsJson);

		return jsonDeserializer.Deserialize<T>(rootAsJson) ??
			throw new InvalidOperationException();
	}

	private async Task<string> GetRootJson(string baseAddress, string requestUri)
	{
		string result = await apiReader.ReadAsync(baseAddress, requestUri);
		return result;
	}

	private string ProcessDateString(string dateString, string formatString)
	{
		if (DateTime.TryParse(dateString, out DateTime dateTime))
		{
			return dateTime.ToString(formatString);
		}
		else
		{
			throw new ArgumentException("Invalid date string format.");
		}
	}

	private double ConvertSecondsToHours(double seconds) => Math.Round((seconds / 3600), 1);

	private async Task<Location?> GetLocation()
	{
		try
		{
			Location location = new();
			location = await JSRuntime.InvokeAsync<Location>("getGeolocation");

			string? latitudeFormatted = location.Latitude.ToString("F4");
			string? longitudeFormatted = location.Longitude.ToString("F4");

			location.Latitude = double.Parse(latitudeFormatted);
			location.Longitude = double.Parse(longitudeFormatted);

			return location;
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex);
			return null;
		}
	}

	public class Location
	{
		public double Latitude { get; set; }
		public double Longitude { get; set; }
	}

	private List<string>? GetAlertEventsForPeriod(ForecastPeriod period)
	{
		List<string>? alerts = new();

		if (_alertRoot?.features is not null)
		{
			foreach (AlertFeature feature in _alertRoot.features)
			{
				AlertProperties properties = feature.properties;

				if (properties.onset <= period.endTime &&
					properties.ends >= period.startTime &&
					!alerts.Contains(properties.@event))
				{
					alerts.Add(properties.@event);
				}
			}
		}

		return alerts;
	}

	private List<string>? GetAlertEventsForToday()
	{
		List<string>? alerts = new();

		if (_alertRoot?.features is not null)
		{
			DateTime today = DateTime.Today;

			foreach (AlertFeature feature in _alertRoot.features)
			{
				AlertProperties properties = feature.properties;

				if ((properties.onset.Date == today || properties.ends.Date == today) &&
					!alerts.Contains(properties.@event))
				{
					alerts.Add(properties.@event);
				}
			}
		}

		return alerts;
	}

	private string GetHourlyForecastImageUrl(HourlyForecastPeriod hourlyForecastPeriod)
	{
		StringComparison comparison = StringComparison.OrdinalIgnoreCase;

		if (hourlyForecastPeriod.shortForecast.Contains("shower", comparison) ||
			hourlyForecastPeriod.shortForecast.Contains("storm", comparison))
		{
			return "images/WeatherElementIcons/showersAndTStorms.png";
		}
		else if (hourlyForecastPeriod.shortForecast.Contains("storm", comparison))
		{
			return "images/WeatherElementIcons/tStorm.png";
		}
		else if (hourlyForecastPeriod.shortForecast.Contains("shower", comparison))
		{
			return "images/WeatherElementIcons/showers.png";
		}
		else if (hourlyForecastPeriod.shortForecast.Contains("cloudy", comparison))
		{
			if (hourlyForecastPeriod.isDaytime)
			{
				return "images/WeatherElementIcons/mostlyCloudyDay.png";
			}

			return "images/WeatherElementIcons/mostlyCloudyNight.png";
		}
		else if (hourlyForecastPeriod.shortForecast.Contains("mostly clear", comparison))
		{
			if (hourlyForecastPeriod.isDaytime)
			{
				return "images/WeatherElementIcons/mostlyClearDay.png";
			}

			return "images/WeatherElementIcons/mostlyClearNight.png";
		}
		else
		{
			if (hourlyForecastPeriod.isDaytime)
			{
				return "images/WeatherElementIcons/sunny.png";
			}

			return "images/WeatherElementIcons/moon.png";
		}
	}

	private string GetForecastImageUrl(ForecastPeriod forecastPeriod)
	{
		StringComparison comparison = StringComparison.OrdinalIgnoreCase;

		if (forecastPeriod.detailedForecast.Contains("sunny", comparison) && forecastPeriod.detailedForecast.Contains("storm", comparison))
		{
			return "images/WeatherElementIcons/sunnyTStorm.png";
		}
		if (forecastPeriod.detailedForecast.Contains("sunny", comparison) && forecastPeriod.detailedForecast.Contains("shower", comparison))
		{
			return "images/WeatherElementIcons/sunnyShowers.png";
		}
		else if (forecastPeriod.detailedForecast.Contains("storm", comparison) && forecastPeriod.detailedForecast.Contains("shower", comparison))
		{
			return "images/WeatherElementIcons/showersAndTStorms.png";
		}
		else if (forecastPeriod.detailedForecast.Contains("storm", comparison))
		{
			return "images/WeatherElementIcons/tStorm.png";
		}
		else if (forecastPeriod.detailedForecast.Contains("shower", comparison))
		{
			return "images/WeatherElementIcons/showers.png";
		}
		else if (forecastPeriod.detailedForecast.Contains("cloudy", comparison))
		{
			if (forecastPeriod.isDaytime)
			{
				return "images/WeatherElementIcons/mostlyCloudyDay.png";
			}

			return "images/WeatherElementIcons/mostlyCloudyNight.png";
		}
		else if (forecastPeriod.detailedForecast.Contains("mostly clear", comparison))
		{
			if (forecastPeriod.isDaytime)
			{
				return "images/WeatherElementIcons/mostlyClearDay.png";
			}

			return "images/WeatherElementIcons/mostlyClearNight.png";
		}
		else
		{
			if(forecastPeriod.isDaytime)
			{
				return "images/WeatherElementIcons/sunny.png";
			}

			return "images/WeatherElementIcons/moon.png";
		}
	}

	private HourlyForecastPeriod GetClosestHourlyForeCast(HourlyForecastRoot hourlyForecastRoot)
	{
		DateTime now = DateTime.Now;
		DateTime nearestHour = new(now.Year, now.Month, now.Day, now.Hour, 0, 0);

		if (now.Minute >= 30)
		{
			nearestHour = nearestHour.AddHours(1);
		}

		foreach (HourlyForecastPeriod period in hourlyForecastRoot.properties.periods)
		{
			if (period.startTime >= nearestHour)
			{
				return period;
			}
		}

		return hourlyForecastRoot.properties.periods.First(); // Fallback
	}

	private string DescribeWindSpeed(string rangeOfWindspeeds)
	{
		int highestWindSpeedInRange = 0;

		MatchCollection matches = Regex.Matches(rangeOfWindspeeds, @"\d+");

		string lastMatch = matches.Last().ToString();

		if (int.TryParse(lastMatch, out int result))
		{
			highestWindSpeedInRange = result;
		}

		if (highestWindSpeedInRange > 0 && highestWindSpeedInRange <= 5)
		{
			return "Breezy";
		}
		else if (highestWindSpeedInRange > 5 && highestWindSpeedInRange <= 30)
		{
			return "Windy";
		}
		else if (highestWindSpeedInRange > 30 && highestWindSpeedInRange <= 75)
		{
			return "Gale Winds!";
		}
		else if (highestWindSpeedInRange > 75)
		{
			return "HURRICANE FORCE WINDS!!!";
		}

		return "Calm";
	}
}