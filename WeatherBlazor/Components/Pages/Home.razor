@page "/"
@rendermode InteractiveServer
@inject IJSRuntime JSRuntime
@inject IApiReaderService apiReader
@inject IJsonDeserializerService jsonDeserializer;
@using System.Text;
@using System.Text.Json.Serialization;
@using System.Text.RegularExpressions
@using WeatherBlazor.Data.Model
@using WeatherBlazor.Services

<PageTitle>Forecast</PageTitle>

<h3>Weather Forecast</h3>

@if (_forecastAsJson is not null)
{
	if (_forecastRoot is not null)
	{
		<div class="forecast-container">
			@foreach (ForecastPeriod period in _forecastRoot.properties.periods)
			{
				<div class="forecast-tile">
					<p><strong>@period.name</strong></p>
					<div class="image-container">
						<img src="@GetImageUrl(period)" alt="Weather icon" class="weather-icon" />
						@if (period.probabilityOfPrecipitation.value > 0)
						{
							<div class="precipitation-chance">
								@period.probabilityOfPrecipitation.value %
							</div>
						}
					</div>
					<p><strong>@period.temperature @period.temperatureUnit</strong></p>
					<p><strong>@period.shortForecast</strong></p>
					<p><strong>@DescribeWindSpeed(period.windSpeed)</strong></p>
				</div>
			}
		</div>

	}


	<style>
		.iframe-container {
			width: 100%;
			height: 600px;
			border: 0;
			overflow: hidden;
		}

			.iframe-container iframe {
				width: 100%;
				height: 100%;
				border: 0;
			}
	</style>

	<div class="iframe-container">
		<iframe
			class="iframe-weatherRadar"
			src="https://radar.weather.gov/?settings=v1_eyJhZ2VuZGEiOnsiaWQiOiJ3ZWF0aGVyIiwiY2VudGVyIjpbLTkzLjE0MSwzNS4yNzhdLCJsb2NhdGlvbiI6Wy05My4xNDEsMzUuMjc4XSwiem9vbSI6NywibGF5ZXIiOiJicmVmX3FjZCJ9LCJhbmltYXRpbmciOnRydWUsImJhc2UiOiJzdGFuZGFyZCIsImFydGNjIjpmYWxzZSwiY291bnR5IjpmYWxzZSwiY3dhIjpmYWxzZSwicmZjIjpmYWxzZSwic3RhdGUiOmZhbHNlLCJtZW51Ijp0cnVlLCJzaG9ydEZ1c2VkT25seSI6dHJ1ZSwib3BhY2l0eSI6eyJhbGVydHMiOjAuNzYsImxvY2FsIjowLjYsImxvY2FsU3RhdGlvbnMiOjAuOCwibmF0aW9uYWwiOjAuNn19"
			allowfullscreen>
		</iframe>
	</div>

	<a href="https://www.vecteezy.com/free-vector/weather">Weather Vectors by Vecteezy</a>
}
else
{
	<p>Loading forecast data...</p>
}



@code{
	private bool _isFirstRender = true;

	private const string _dayFormat = "dddd";
	private const string _timeFormat = "HH:mm";

	private Location? _location;

	private const string _baseAddress = "https://api.weather.gov/";

	private string? _forecastAsJson;
	private string? _pointRootAsJson;

	private PointRoot? _pointRoot;
	private ForecastRoot? _forecastRoot;

	private void SetForecastRoot(string forecastAsJson)
	{
		ArgumentNullException.ThrowIfNull(forecastAsJson);
		_forecastRoot = jsonDeserializer.Deserialize<ForecastRoot>(forecastAsJson);
	}

	private void SetPointRoot(string pointRootAsJson)
	{
		ArgumentNullException.ThrowIfNull(pointRootAsJson);
		_pointRoot = jsonDeserializer.Deserialize<PointRoot>(pointRootAsJson);
	}

	private T SetRoot<T>(string rootAsJson)
	{
		ArgumentNullException.ThrowIfNull(rootAsJson);

		return jsonDeserializer.Deserialize<T>(rootAsJson) ??
			throw new InvalidOperationException();
	}

	private async Task GetPointRootJson(string pointRequestUri)
	{
		_pointRootAsJson = await apiReader.ReadAsync(_baseAddress, pointRequestUri);
	}

	private async Task GetForecastJson(string forecastRequestUri)
	{
		_forecastAsJson = await apiReader.ReadAsync(_baseAddress, forecastRequestUri);
	}

	private string ProcessDateString(string dateString, string formatString)
	{
		if (DateTime.TryParse(dateString, out DateTime dateTime))
		{
			return dateTime.ToString(formatString);
		}
		else
		{
			throw new ArgumentException("Invalid date string format.");
		}
	}

	private double ConvertSecondsToHours(double seconds) => Math.Round((seconds / 3600), 1);

	private async Task<Location?> GetLocation()
	{
		try
		{
			Location location = new();
			location = await JSRuntime.InvokeAsync<Location>("getGeolocation");

			string? latitudeFormatted = location.Latitude.ToString("F4");
			string? longitudeFormatted = location.Longitude.ToString("F4");

			location.Latitude = double.Parse(latitudeFormatted);
			location.Longitude = double.Parse(longitudeFormatted);

			return location;
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex);
			return null;
		}
	}

	public class Location
	{
		public double Latitude { get; set; }
		public double Longitude { get; set; }
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (_isFirstRender)
		{
			_isFirstRender = false;

			_location = await GetLocation();

			if (_location is null)
			{
				Console.WriteLine("Location data is not available.");
				return;
			}

			string pointRequestUri = string.Empty;
			if (_location is not null)
			{
				pointRequestUri = $"/points/{_location.Latitude},{_location.Longitude}";
			}

			await GetPointRootJson(pointRequestUri);

			_pointRoot = SetRoot<PointRoot>(_pointRootAsJson ??
				throw new ArgumentNullException(
					$"{nameof(SetRoot)} was called with {nameof(_pointRootAsJson)} as null."));

			string? forecastFullUrl = _pointRoot?.properties.forecast;
			string? forecastUri = forecastFullUrl?[_baseAddress.Length..];

			await GetForecastJson(forecastUri ??
				throw new ArgumentNullException(
					$"{nameof(GetForecastJson)} was called with {nameof(forecastUri)} as null."));

			_forecastRoot = SetRoot<ForecastRoot>(_forecastAsJson ??
				throw new ArgumentNullException(
					$"{nameof(SetRoot)} was called with {nameof(_forecastAsJson)} as null."));

			StateHasChanged();
		}
	}

	private string GetImageUrl(ForecastPeriod period)
	{
		StringComparison comparison = StringComparison.OrdinalIgnoreCase;

		if (period.detailedForecast.Contains("sunny", comparison) && period.detailedForecast.Contains("storm", comparison))
		{
			return "images/WeatherElementIcons/sunnyTStorm.png";
		}
		if (period.detailedForecast.Contains("sunny", comparison) && period.detailedForecast.Contains("shower", comparison))
		{
			return "images/WeatherElementIcons/sunnyShowers.png";
		}
		else if (period.detailedForecast.Contains("storm", comparison) && period.detailedForecast.Contains("shower", comparison))
		{
			return "images/WeatherElementIcons/showersAndTStorms.png";
		}
		else if (period.detailedForecast.Contains("storm", comparison))
		{
			return "images/WeatherElementIcons/tStorm.png";
		}
		else if (period.detailedForecast.Contains("shower", comparison))
		{
			return "images/WeatherElementIcons/showers.png";
		}
		else if (period.detailedForecast.Contains("mostly cloudy", comparison))
		{
			if (period.isDaytime)
			{
				return "images/WeatherElementIcons/mostlyCloudyDay.png";
			}

			return "images/WeatherElementIcons/mostlyCloudyNight.png";
		}
		else if (period.detailedForecast.Contains("mostly clear", comparison))
		{
			if (period.isDaytime)
			{
				return "images/WeatherElementIcons/mostlyClearDay.png";
			}

			return "images/WeatherElementIcons/mostlyClearNight.png";
		}
		else
		{
			if(period.isDaytime)
			{
				return "images/WeatherElementIcons/sunny.png";
			}

			return "images/WeatherElementIcons/moon.png";
		}
	}

	private string DescribeWindSpeed(string rangeOfWindspeeds)
	{
		int highestWindSpeedInRange = 0;

		MatchCollection matches = Regex.Matches(rangeOfWindspeeds, @"\d+");

		string lastMatch = matches.Last().ToString();

		if (int.TryParse(lastMatch, out int result))
		{
			highestWindSpeedInRange = result;
		}

		if (highestWindSpeedInRange > 0 || highestWindSpeedInRange <= 5)
		{
			return "Breezy";
		}
		else if (highestWindSpeedInRange > 5 || highestWindSpeedInRange <= 30)
		{
			return "Strong Winds";
		}
		else if (highestWindSpeedInRange > 30 || highestWindSpeedInRange <= 75)
		{
			return "Gale Winds!";
		}
		else if (highestWindSpeedInRange > 75)
		{
			return "HURRICANE FORCE WINDS!!!";
		}

		return "Calm";
	}
}